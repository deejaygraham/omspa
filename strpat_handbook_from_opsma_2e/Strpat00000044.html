<html>

<head>
<title>Real-time (what I do)</title>
</head>

<body>
<b>

<p>Real-time (what I do) </p>

<p></b><i>Str#106. &quot;Real Time: Timeliness&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- Timeliness: must be &quot;on time&quot; </p>

<p>- Put performance constraints on your scenarios (on services, too, as needed--although
allocating performance constraints to individual services often takes more guesswork than
most engineers feel comfortable with). </p>

<p><i>Str#107. &quot;Real Time: Dynamic Internal Structure&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- Dynamic internal structure: dynamic creation and destruction of software
components </p>

<p>- How: show dynamic creation and deletion of objects in scenarios. </p>

<p>. Every class knows how to create new objects in that class. </p>

<p>. Every collection knows how to add and remove objects in that collection. </p>

<p>. Every object knows how to delete itself. </p>

<p>. In addition, you can selectively place additional creation and deletion constraints. </p>

<p><i>Str#108. &quot;Real Time: Reactiveness&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- Reactiveness: continuously responds to different events in its environment,
detected by data acquisition and control devices, or by interacting systems </p>

<p>- Use a specific &quot;maintain&quot; or &quot;monitor&quot; service, for ongoing
capabilities. </p>

<p>- Use the &quot;activate, monitor, deactivate&quot; triad. </p>

<p><i>Str#109. &quot;Real Time: State-Dependency&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- State-dependency: responds differently, depending upon the state of a system </p>

<p>- Attributes: state, state-dependent, state-independent </p>

<p>. In its description, include: applicable states. </p>

<p>- Services: state-dependent, state-independent </p>

<p>. In its description, you may need to include: </p>

<p>. . precondition: &amp;ltindicate what you assert to be true, before this service can
run&gt; </p>

<p>. . postcondition: &amp;ltindicate what you assert to be true, before this service can
go to completion&gt; </p>

<p>. . trigger condition: &amp;ltindicate what state transitions activate this service&gt;
</p>

<p>. . terminate condition: &amp;ltindicate what state transitions terminate this
service&gt; </p>

<p>. . exception: &amp;ltindicate object.service to invoke, upon detecting an
exception&gt;. </p>

<p><i>Str#110. &quot;Real Time: Concurrency&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- Concurrency: multiple simultaneous activities can be taking place. </p>

<p>- Objects can do more than one thing at once -- they are multitasking creatures. </p>

<p>- Objects encapsulate real-time tasks. </p>

<p>. Activation / deactivation </p>

<p>. . Trigger condition: &amp;ltrequest, state change, value change, time lapse&gt; </p>

<p>. . Terminate condition: &amp;ltrequest, state change, value change, time lapse&gt; </p>

<p>. Communication, coordination </p>

<p>. Communication between objects is by synchronous messaging. </p>

<p>. Communication within objects is by synchronous and asynchronous messaging, as needed.
</p>

<p>- Note: this encapsulation is made possible with effective object modeling (not with
data objects and controller objects). </p>

<p><i>Str#111. &quot;Real Time: Multiple Device Abstractions&quot; Strategy //
establishing responsibilities / what I do (real time) </p>

<p></i>- Multiple device abstractions: needs both physical and logical abstractions. </p>

<p>- Physical abstraction -- express with an object in the system interaction component. </p>

<p>- Logical abstractions -- express with: </p>

<p>. a domain-based object (a problem-domain object) </p>

<p>. an object which shows &quot;this is how we'll work with it&quot; (a human interaction
object) </p>

<p>. an object which persists from one program invocation to the next (a data management
object). </p>

<p><i>Str#112. &quot;Real Time: Distribution&quot; Strategy // establishing
responsibilities / what I do (real time) </p>

<p></i>- Distribution: multiple computing sites </p>

<p>- Across multiple computing systems </p>

<p>. Use software that supports distributed objects. </p>

<p>. Or do it yourself (inevitable, at least for systems that you must interact with and
cannot change). </p>

<p>. . Allocate objects, not mere functionality. </p>

<p>. . Add &quot;pack and ship; receive and route&quot; infrastructure. </p>

<p>- Within an existing system </p>

<p>. Use an object model to understand what's really going on. </p>

<p>. Tag each service with its location; tag each attribute with who is using it. </p>

<p><a HREF="Strpat00000039.html">Establishing responsibilities / what I do</a> </p>

<p><a HREF="Strpat00000015.html">Strategies for building object models</a> </p>
</body>
</html>
